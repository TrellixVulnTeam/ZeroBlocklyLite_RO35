#include "IRremote.h"
#include "IRremoteInt.h"

// Reverse Engineered by looking at RAW dumps generated by IRremote

// I have since discovered that Denon publish all their IR codes:
//  https://www.google.co.uk/search?q=DENON+MASTER+IR+Hex+Command+Sheet
//  -> http://assets.denon.com/documentmaster/us/denon%20master%20ir%20hex.xls

// Having looked at the official Denon Pronto sheet and reverse engineered
// the timing values from it, it is obvious that Denon have a range of
// different timings and protocols ...the values here work for my AVR-3801 Amp!

//==============================================================================
//                     ZZZZZ   EEEEE  RRRR    OOO
//                        Z    E      R   R  O   O
//                       Z     EEEE   RRRR   O   O
//                      Z      E      R R    O   O
//                     ZZZZZ   EEEEE  R  R    OOO
//==============================================================================

#define BITS          14  // The number of bits in the command

#define DRKIM_MARK   1200  // The length of the Header:Mark. This value is the head MARK time in microseconds. For DrKim, this value is 1200us, that is 24 samples. This also means that there a 8 samples per bit.
#define HDR_SPACE    750  // The lenght of the Header:Space

#define BIT_MARK     300  // The length of a Bit:Mark
#define ONE_SPACE   1800  // The length of a Bit:Space for 1's
#define ZERO_SPACE   750  // The length of a Bit:Space for 0's

//+=============================================================================
//


//+=============================================================================
//
#if DECODE_DRKIM
bool  IRrecv::decodeDrKim (decode_results *results)
{
	unsigned long  data   = 0;  // Somewhere to build our code
	int            offset = 1;  // Skip the Gap reading

    int succesive_bits_number = 0;
    unsigned int raw_IR_sampled_data[count];
	unsigned long final_raw_data = 0;
	int total_bits = 0;
    int total_shift = 0;

	// Check we have the right amount of data
	if (irparams.rawlen != 18)  return false ;                                 //According to the all data captured, the amount of data of DrKim IR controller sends 18 amount of MARK&SPACE.

	// Check initial Mark+Space match
	if (!MATCH_MARK (results->rawbuf[offset], DRKIM_MARK ))  return false ;    //Compare the first MARK time(head, which is 3 bits long) with 1200us(default 3 bits long, that means each bit is 400us/bit).



    for (int raw_i = 1; raw_i < irparams.rawlen; raw_i++) {      //caculate the total number of bits that recieved
      succesive_bits_number = floor(results->rawbuf[raw_i] / 7); //This is to translate the successive time into bits based on a 7samples/bit(350us/bit)

      if (succesive_bits_number == 0) succesive_bits_number = 1;
      total_bits += succesive_bits_number;

    }

    total_shift = total_bits;

	// Read the bits in
	for (int i = 0;  i < total_bits;  i++) {
		// Each bit looks like: MARK + SPACE_1 -> 1
		//                 or : MARK + SPACE_0 -> 0
		if (!MATCH_MARK(results->rawbuf[offset++], BIT_MARK))  return false ;

		// IR data is big-endian, so we shuffle it in from the right:
		if      (MATCH_SPACE(results->rawbuf[offset], ONE_SPACE))   data = (data << 1) | 1 ;
		else if (MATCH_SPACE(results->rawbuf[offset], ZERO_SPACE))  data = (data << 1) | 0 ;
		else                                                        return false ;
		offset++;
	}

	// Success
	results->bits        = total_bits;
	results->value       = data;
	results->decode_type = DENON;
	return true;
}
#endif
